
usage: ./configure [ variable=value ]...

Generates the following files: 
- makefile: used to build (run "make") and install (run "make install")
- ../include/NTL/config.h: used by NTL source code
- ../include/NTL/CONFIG_LOG.txt: summary of the configuration setting
- ../include/NTL/USER_MAKEFILE.txt: makefile that can be used for simple 
     applications or modified for other applications.  It's useful to look 
     at this makefile to see what compiler flags are used and why.
- ../lib/pkgconfig/ntl.pc: a pkg-config file that can be useful for integrating
     NTL into build systems like Cmake/Meson/


Each configuration variable FOO is shown with its defailt value bar as FOO=bar.
For on/off switches, the only possible values are 'on' and 'off'

################### The most important variables ###################

########## Basic compilation variables:

CXX=g++

# A C++ compiler, e.g., g++, CC, xlC


CXXFLAGS=-g -O2

# Flags for the C++ compiler 

# It is highly recommend to avoid things like -O3 and -Ofast.  These may yield
# incorrect code.

NATIVE=on   # on/off switch

# Turning this on will pass -march=native through to the compiler via
# CXXAUTOFLAGS (see below).  This is the easiest way to exploit the hardware
# capabilities of your machine to their fullest potential. 

# Note that on Arm-based machines, instead of -march-native, the flag
# -mcpu=native is used. For weird historical reasons, one has to use
# -mcpu-native to get the desired behavior (although new releases of gcc and
# clang may start to treat -march=native the same as -mcpu-native).

# Note that if CXXFLAGS contains a flag -march, -mcpu, or -mtune flag, then
# NATIVE will be turned off.

######### Auxilliary software packages

#### GMP 

NTL_GMP_LIP=on   # on/off switch

# By default, NTL will use GMP, the GNU Multi-Precision package.
# Turning this off will eliminate the dependency on GMP, but
# is not recommended as it will will lead to significantly slower code.

# If NTL_GMP_LIP=on, the prefix GMP_PREFIX may need to be set (see below).


#### GF2X 

NTL_GF2X_LIB=off   # on/off switch

# Turn this on to use the GF2X library for faster arithmetic over GF(2)[X]
# (the NTL class GF2X).

# If NTL_GF2X_LIB=on, the prefix GF2X_PREFIX may need to be set (see below).



########## Paths for installation and auxilliary software components

SYS_PREFIX=/usr/local

# A standard "system" prefix where software components can be found at compile,
# link, and run time without any compiler flags such as -I, -L, or -Wl,-rpath
# (and these flags *will not* be included in the generated makefile).

DEF_PREFIX=$(SYS_PREFIX)

# A "default" prefix where software components can be found at compile, link,
# and run time with appropriate compiler flags (and these flags *will* be
# included in the generated makefile). 

#### installation

PREFIX=$(DEF_PREFIX)

# Prefix where NTL components are to be installed.  When "make install" is
# executed, the following files are installed:
# - header files, CONFIG_LOG.txt, USER_MAKEFILE.txt in $(INCLUDEDIR)/NTL,
#   where INCLUDEDIR=$(PREFIX)/include 
# - library file(s) libntl.{a,so} in $(LIBDIR), where LIBDIR=$(PREFIX)/lib
# - documentation files in $(DOCDIR)/NTL, ehre DOCDIR=$(PREFIX)/share/doc
# - pkg-config file ntl.pc in $(PKGDIR), where PKGDIR=$(PREFIX)/lib/pkgconfig
# The variables INCLUDEDIR, LIBDIR, DOCDIR, PKGDIR may be overridden. 

#### GMP

GMP_PREFIX=$(DEF_PREFIX)

# Prefix at which GMP components have been installed. Needed if NTL_GMP_LIP=on
# and GMP components are not installed in a standard "system" prefix.
# - header file gmp.h in $(GMP_INCDIR), where GMP_INCDIR=$(GMP_PREFIX)/include 
# - library file(s) libgmp.{a,so} in $(GMP_LIBDIR), where
#   GMP_LIBDIR=$(GMP_PREFIX)/lib
# The variables GMP_INCDIR, GMP_LIBDIR may be overridden.

#### GF2X

GF2X_PREFIX=$(DEF_PREFIX)

# Prefix at which GF2X components have been installed. Needed if
# NTL_GF2X_LIB=on and GF2X components are not installed in a standard "system"
# prefix.
# - header file gf2x.h in $(GF2X_INCDIR), where
#   GF2X_INCDIR=$(GF2X_PREFIX)/include 
# - library file(s) libgf2x.{a,so} in $(GF2X_LIBDIR), where
#   GF2X_LIBDIR=$(GF2X_PREFIX)/lib
# The variables GF2X_INCDIR, GF2X_LIBDIR may be overridden.


#### Example:
# If you do not set DEF_PREFIX, GMP_PREFIX, or GMP_INCDIR, it will be assumed
# that the GMP header file gmp.h is installed in $(SYS_PREFIX)/include and that
# a -I flag is not needed to find it.  If you set DEF_PREFIX, but not
# GMP_PREFIX or GMP_INCDIR, it will be assumed that the GMP header file gmp.h
# is installed in $(DEF_PREFIX)/include and a -I$(DEF_PREFIX)/include will be
# included in the generated makefile.  Similar assumptions are made for finding
# the GMP library itself at link time (with a possible -L flag) and at run time
# (with a possible -Wl,-rpath flag).

########## Shared libraries and libtool

SHARED=off   # on/off switch 

# By default, only a static library is built.  Turn this on to build a shared
# library, in addition to a static library.  If SHARED=on, the makefile will
# use libtool to build the library.

ENABLE_LIBTOOL=off   # on/off switch

# Athough mainly needed to build a shared library, one can also use libtool to
# build a static library. This can be helpful to integrate NTL into a "libtool
# ecosystem". For example, this allows you to use libtool to build programs
# that use NTL, which gives you convenient access to more linkage options via
# libtool (for example, the -static-libtool-libs option could be used to ensure
# that NTL itself, as well as all of its dependencies, are linked as static
# libraries, even if shared libraries are also available).

# If SHARED=on, then ENABLE_LIBTOOL is automatically turned on.  

PREFER_PIC=off   # on/off switch

# Turning on this switch will pass the option -prefer-pic to libtool diring
# compilation, which will ensure that the code in static a static library is
# position independent.  This can allow a static NTL library to be linked to by
# a shared library. Note that on macOS, the compiler generates
# position-indpendent code by default, so this is not necessary. However, on
# Linux you will need to turn this switch on.

LIBTOOL=undefined

# If ENABLE_LIBTOOL=on, the makefile will use a libtool script.  By default,
# this script is freshly built by the configure script. Note that when using
# libtool, some modern make features (certainly available on gnu make).
#
# One can also define LIBTOOL to point to a pre-built libtool program.  Note
# that on macOS, there is a program called libtool, but it cannot be used.
# Instead, a program called glibtool is necessary, which is typically available
# through popular package management systems.



############# Rpath madness

ENABLE_RPATH=undefined   # on/off switch 

# You typically link a program to a library foo by passing
# -L/path/to/foo/library -lfoo to the compiler. However, if foo is a shared
# library, then on some Linux systems, this it not enough to ensure that the
# library foo in /path/to/foo/library is found at runtime.  It may happen that
# the library is not found at all, or worse, a different version of the library
# is found rather than the one in /path/to/foo/library.
  
# This is especially problematic on systems where GMP has been installed as a
# suboptimally compiled system library and you want to use an optimally
# compiled GMP in a non-standard location. If you are not careful, you may end
# up loading the suboptimal GMP at runtime, even though you linked to the
# optimal GMP at link time.
  
# If you are on macOS, this is generally not a problem, as the runtime shared
# library loader will look first for the library in the location specified at
# link time.  On Linux, the safest way to make sure this happens is to link
# your program with the additional compiler option
# -Wl,-rpath,/path/to/foo/library.  This is actually a fairly standard option,
# widely supported across various flavors of Unix. 
  
# Both during the NTL build process several test programs are run and it is
# important to make sure NTL's dependencies are correctly linked to these
# programs, using -Wl,-rpath if necessary.  If ENABLE_RPATH is turned on, the
# makefile will attempt to use -Wl,-rpath as necessary.  
  
# If left undefined, the configure script will heuristically turn it on or off,
# depending on your system.  However, if explicitly defined by passing an
# argument ENABLE_RPATH={on,off} to the configure script, that choice will be
# respected.


################### Other variables ###################

######### tuning

TUNE=generic (or x86 or linux-s390x)

# Switch to determine how various performance options get set
#   auto        make runs a performance-tuning wizard when you run make 
#   generic     should be OK for most platforms
#   x86         should be well suited for most x86 platforms
#   linux-s390x should be well suited for Linux on IBM Z platforms 
#               from z15 onward
#   off         no performance options set (but they can be set individually
#               as configuration options)

# More choices may be added in the future.
# Right now, the default is
# - x86, if configure detects that is is running on an x86 platform,
# - linux-s390x, if configure detects that it is running on Linux on an 
#   IBM Z platform and the compiler is either gcc or clang, and
# - generic, otherwise.


########## thread safety

NTL_THREADS=on   # on/off switch

# Turn on if you want to compile NTL in thread-safe mode.  This requires
# several C++11 features, including atomic types, mutexes, and thread_local
# storage.  Setting this flag will automatically set the NTL_STD_CXX11 flag (if
# neither NTL_STD_CXX11 or NTL_STD_CXX14 is already set). It will also pass
# -pthread throught to the compiler via CXXAUTOFLAGS (if possible).
#
# Turning this flag off will also turn off the NTL_THREAD_BOOST flag.

########## thread boosting

NTL_THREAD_BOOST=on   # on/off switch

# Turn on if you want to compile NTL so that it does certain internal
# computations using multiple threads using thread pools.  NTL implements its
# own thread pool mechanism using standard C++ and does not rely on any other
# libraries.  You can also use this thread pool mechanism in your own project.
# See BasicThreadPool documentation file for more details.

########## exceptions

NTL_EXCEPTIONS=off   # on/off switch

# Turn on if you want to compile NTL with exceptions enabled.  This requires
# several C++11 features, including lambdas and the new rules for exception
# specifications.  Setting this flag will automatically set the NTL_STD_CXX11
# flag (if neither NTL_STD_CXX11 or NTL_STD_CXX14 is already set).

# With exceptions disabled, any error conditions detected by NTL (including
# memory allocation errors) will result in an error message and a call to
# abort.  Also, if compiling in C++11 mode (or later, see NTL_STD_CXX11), with
# exceptions disabled, certain move constructors and move assignment operators
# will be declared "noexcept".  This can lead to greater efficiency (for
# example, std::vector's take advantage of this to avoid call to copy 
# contructors).

# With exceptions enabled, most error conditions detected by NTL will result in
# an exception being thrown.  NTL will also be compiled in an "exception safe"
# mode that prevents memory leaks (and other problems).  In addition, some move
# constructors and move assignment operators may not be declared "noexcept".

########### Language standards

NTL_STD_CXX11=on   # on/off switch to build assuming C++11 features
NTL_STD_CXX14=off  # on/off switch to build assuming C++14 features

# Setting one of these may also result in passing pass either -std=c++11 or
# -std=c++14 through to the compiler via CXXAUTOFLAGS (see below).

# These flags are mostly obsolete by now, as most C++ compilers nowadays are
# running a standard of C++11 or higher by default.


############ Safe vector mode

NTL_SAFE_VECTORS=on  # Build in "safe vector mode"

# Build NTL in "safe vector mode", which relaxes the "relocatability"
# requirement for NTL vector types. I expect that at some point in the next
# couple of years, this will be "on" by default.  Setting this flag will
# automatically set the NTL_STD_CXX11 flag (if neither NTL_STD_CXX11 or
# NTL_STD_CXX14 is already set).  See vector documentation file for more
# details.


############ AVX FFT

NTL_ENABLE_AVX_FFT=off   # on/off switch

# implement the small-prime FFT using AVX  instructions...this is experimental
# at the  moment, and may lead to worse performance

# On machines with AVX2/FMA or AVX512, this will implement the small-prime FFT
# using AVX code.  This is still quite experimental, and may lead to worse
# performance.  While the FFT itself can run 2-3 times faster, this comes at
# the cost of (1) restriction to 50-bit primes (so NTL_SP_NBITS will be set to
# 50 instead of 60), and (2) the CPU speed may be throttled, slowing down other
# operations.  So far, it seems that the only operations that are faster are
# arithmetic operations in zz_pX, and only for certain choices of modulus.
# Arithmetic operations in ZZ_pX, with large modulus, can run slower with AVX
# than without.


########### Avoid 512-bit AVX registers

NTL_AVOID_AVX512=off   # on/off switch

# avoid using 512-bit AVX registers

# Even if available, this will avoid the use of 512-bit AVX registers.  This
# affects both Mat<zz_p> operations, as well as the AVX-based FFT (see above).


########### Use AES-256-CTR based pseudorandom generator

NTL_RANDOM_AES256CTR=off   # on/off switch
 
# implement pseudorandom generator using AES-256-CTR

# AES-256-CTR based pseudorandom generation may be faster than the
# default in case AES instruction set extensions are available on
# the processor and supported by the implementations.
# 
# The implementation supports the following AES instruction set
# extensions if detected at build time:
# 
#  x86         : AES-NI
#  linux-s390x : KMA
# 
# Be aware of possible interoperability issues when changing
# the implementation of NTL's pseudorandom generator object.



################### A little magic ###################


CXXAUTOFLAGS=

# This is a variable that is automagically set by the configuration script.
# These are C++ compiler flags that are selected depending on the choice of
# other configuration options, as well as information gleaned by the
# configuration script about the compiler.  To do this, the configuration
# script attempts to figure out the type of compiler and the default language
# standard supported.  The types of compiler currently recognized are gcc,
# clang, and icc.  For these compilers, the automagic should definitely work.
# For others, your mileage may vary.  The configuration script always prints
# out the value it chooses.  Currently, the following flags may get passed
# through CXXAUTOFLAGS:
#
#   -march=native
#   -mcpu=native       if requested explicitly via NATIVE=on
#
#   -std=c++11 
#   -std=c++14         if requested explicitly via NTL_STD_CXX11=on or 
#                      NTL_STD_CXX14=on, or implicitly via a request
#                      for a feature that requires C++11
#
#   -pthread           if thread-safety is requested via NTL_THREADS=on 
#                      or NTL_THREAD_BOOST=on
#
#   -fp-model precise  only for the Intel icc compiler (to prevent
#                      non-value-preserving floating point optimizations)
#
# If you explicitly set the value of CXXAUTOFLAGS when invoking the
# configuration script, then it will not change that value.

NOCONTRACT=

# Like the CXXAUTOFLAGS variable, this is set automagically by the
# configuration script, unless you explicitly provide a value.  It is only used
# in compiling the source files that implement the quad_float class and the AVX
# FFT.  For these files only, NTL requires not only that the compiler does not
# perform any non-value-preserving floating point optimizations, but that is
# also does not perform any "contractions" (i.e., emit FMA (fused multiply add)
# instructions.  Currently, it may be set as follows:
# 
#   -ffp-contract=off   for gcc (and possibly clang) compilers 
#
#   -mno-fused-madd     for old gcc compilers that don't support 
#                       -ffp-contract=off
#   -DFP_CONTRACT_OFF   for the Intel icc compiler
#
# The configuation script will make every attempt to ensure that this really
# does disable contractions.  If it doesn't work, a fallback strategy is used
# that should still work (but with a performance penalty).


MAKE_PROG=make

# The configure script actually needs to run make at various points.  If you
# wish to use a non-standard make program for this purpose, set this variable
# to point to that program.



################### Esoterica ###################

# Here is a complete list of the remaining variables, with their default
# values.  These variables are pretty esoteric, and you will probably never
# change their default values.

AR=ar
ARFLAGS=ruv
RANLIB=ranlib
LDFLAGS=
LDLIBS=-lm
CPPFLAGS=
LIBTOOL_LINK_FLAGS=
LIBTOOL_LINK_LIBS=undefined

NTL_TLS_HACK=on

NTL_DISABLE_MOVE_ASSIGN=on
NTL_DISABLE_MOVE=off

NTL_LEGACY_NO_NAMESPACE=off
NTL_LEGACY_INPUT_ERROR=off

NTL_LEGACY_SP_MULMOD=off

NTL_UNSIGNED_LONG_LONG_TYPE=undefined
NTL_CLEAN_INT=off
NTL_CLEAN_PTR=on
NTL_RANGE_CHECK=off
NTL_X86_FIX=off
NTL_NO_X86_FIX=off
NTL_NO_INIT_TRANS=on
NTL_DISABLE_LONGDOUBLE=off
NTL_DISABLE_LONGLONG=off
NTL_DISABLE_LL_ASM=off
NTL_MAXIMIZE_SP_NBITS=off

NTL_SPMM_ULL=off
NTL_FFT_BIGTAB=off
NTL_FFT_LAZYMUL=off
NTL_TBL_REM=off
NTL_AVOID_BRANCHING=off
NTL_GF2X_NOINLINE=off
NTL_GF2X_ALTCODE=off
NTL_GF2X_ALTCODE1=off


# Here is a more detailed description of these variables.

########### Further compilation variables:


AR=ar

# command to make a library



ARFLAGS=ruv

# arguments for AR


RANLIB=ranlib

# set to echo if you want to disable it completely


LDFLAGS=

# arguments for linker for C++ programs


LDLIBS=-lm

# libraries for linking C++ programs


CPPFLAGS=

# arguments for the C preprocessor


LIBTOOL_LINK_FLAGS=

# flags to add to command line when building a shared library.
# For very obscure reasons, you may need to set this to "-no-undefined" on 
# cygwin

LIBTOOL_LINK_LIBS=undefined

# libraries to add to the command line when building a shared library.
# mainly used to pass the argument "-lpthread", which NTL's
# configure script will do automatically if ENABLE_LIBTOOL=on 
# and NTL_THREADS=on, unless user explicitly provides a value for 
# LIBTOOL_LINK_LIBS.
# the purpose of this is to prevent so-called "underlinking".
# specifically, it allows NTL clients to not pass "-pthread" to the
# compiler when linking their own programs.


########### Details of the compilation process (when SHARED=off)


# When a C++ file foo.c is compiled:
   $(CXX) -I../include $(CPPFLAGS) $(CXXFLAGS) -c foo.c

# When a C++ file foo.c is compiled and linked:
   $(CXX) -I../include $(CPPFLAGS) $(CXXFLAGS) $(LDFLAGS) \ 
      -o foo foo.c $(LDLIBS)

# When the library ntl.a is built
   $(AR) $(ARFLAGS) ntl.a [ object files ]...
   $(RANLIB) ntl.a
# If the ranlib command does not exist, everything will still function OK.



########## TLS hack

NTL_TLS_HACK=on

# when building NTL with NTL_THREADS=on, if the compiler is gcc-compatible, a
# "TLS hack" may be used to workaround the fact that many compilers do not
# (correctly) implement C++11's thread_local feature.  The workaround is to use
# gcc's more limited __thread feature, and to emulate thread_local semantics
# using pthread routines.
# 
# The configuration script will first check if threads and TLS work with the
# hack, and if not, will try setting NTL_TLS_HACK=off.  You can also turn off
# the hack by setting NTL_TLS_HACK=off.


########## Disabling move semantics

NTL_DISABLE_MOVE_ASSIGN=on
NTL_DISABLE_MOVE=off

# The first flag will disable the generation of move assignment operators for
# Vec<T>, Mat<T>, vec_GF2, and GF2X.  By implication, move assignment operators
# will be disabled as well for many other types (like polynomials).  The second
# flag will disable move constuctors and move assignment operators for all NTL
# types.
#
# These flags are only relevant in C++11 mode.  They are meant to deal with
# backward compatibility issues for legacy NTL clients that may not deal well
# with automatically generated move operations.  It turns out that move
# semantics can quietly break programs.  See
# http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3153.htm 
# However, the default now is just to disable move assignment operators for
# those classes where it seems likeliest to cause a problem.  This default will
# likely be changed in the future, so that no move operations are disabled.



########## Legacy switches

NTL_LEGACY_NO_NAMESPACE=off 

# put NTL components in the global namespace



NTL_LEGACY_INPUT_ERROR=off

# abort on input errors, instead of just setting the
# "fail bit" of the istream object

NTL_LEGACY_SP_MULMOD=off

# use pre-9.0 interfaces for single-precision MulMod routines.
# See discussion in ZZ.txt for details.



########### Basic Configuration Options:

NTL_UNSIGNED_LONG_LONG_TYPE=undefined

# Name of double-word unsigned integer type.  This is a non-standard type, and
# is called 'long long' by many compilers.  MS C++ calls it 'unsigned __int64'.
#
# Note that the new C99 standard defines the type 'unsigned long long' to be at
# least 64-bits wide.  On 32-bit machines, this is just right.  Although not
# officially part of the C++ standard (which predates C99), it is widely
# supported by C++ compilers, and is likely to be added to the C++ standard.
#
# Unfortunately, 64-bit machines usually define 'unsigned long long' to also be
# 64-bits wide, which is kind of useless.  However, GCC provides a type
# __uint128_t which does the job.
#
# If left undefined, NTL will use some "ifdef magic" to find the type most
# suitable for your machine (based on compiler and word size).



NTL_CLEAN_INT=off

# Setting this to 'on' disables the use of some non-standard integer arithmetic
# which would yield slightly better performance.


NTL_CLEAN_PTR=on

# Setting this to 'on' disables the use of some non-standard pointer arithmetic
# which would yield slightly better performance.  The 'off' setting really just
# invites undefined behavior without any measurable performance benefit. 


NTL_RANGE_CHECK=off

# Setting this to 'on' will generate vector subscript range-check code.  Useful
# for debugging, but it slows things down of course.



NTL_X86_FIX=off

# Set to 'on' to force the "x86 floating point fix", overriding the default
# behavior.  By default, NTL will apply the "fix" if it looks like it is
# necessary, and if it knows how to fix it.  The problem addressed here is that
# x86 processors sometimes run in a mode where FP registers have more precision
# than doubles.  This will cause code in quad_float.c some trouble.  NTL can
# normally automatically detect the problem, and fix it, so you shouldn't need
# to worry about this or the next flag.



NTL_NO_X86_FIX=off

# Set to 'on' to forces no "x86 floating point fix", overriding the default
# behavior.



NTL_NO_INIT_TRANS=on

# When 'off', NTL uses a special code sequence to avoid copying large objects
# in return statements.  However, if your compiler optimizes away the return of
# a *named* local object, this is not necessary, and setting this flag to 'on'
# will result in *slightly* more compact and efficient code.  The C++ standard
# explicitly allows compilers to perform this optimization, and with time, more
# compilers actually do this.  Traditionally, however, most will only avoid
# copying *temporary* objects in return statements, and NTL's default code
# sequence exploits this fact.



NTL_DISABLE_LONGDOUBLE=off

# Explicitly disables use of long double arithmetic 

NTL_DISABLE_LONGLONG=off

# Explicitly disables use of long long arithmetic 

NTL_DISABLE_LL_ASM=off

# Explicitly disables use of inline asm as replacement for
# long long arithmetic

NTL_MAXIMIZE_SP_NBITS=on

# Allows for 62-bit single-precision moduli on 64-bit platforms.  By default,
# such moduli are restricted to 60 bits, which usually gives *slightly* better
# performance across a range of of parameters.





########## Performance Options:


NTL_SPMM_ULL=off

# Implement the MulModPrecon code using "unsigned long long" (or specify
# NTL_UNSIGNED_LONG_LONG_TYPE to override the default).


NTL_FFT_BIGTAB=off

# Precomputed tables are used to store all the roots of unity used in FFT
# computations. 


NTL_FFT_LAZYMUL=off

# When set, a "lazy multiplication" strategy due to David Harvey: see his paper
# "FASTER ARITHMETIC FOR NUMBER-THEORETIC TRANSFORMS".



NTL_TBL_REM=off

# With this flag, some divisions are avoided in the ZZ_pX multiplication
# routines.  



NTL_AVOID_BRANCHING=off

# With this option, branches are replaced at several key points with equivalent
# code using shifts and masks.  Recommended for use with RISC architectures,
# especially ones with deep pipelines and high branch penalities.  Newer x86
# platforms that use conditional move intrictions are slightly faster without
# this option.  When in doubt, turn this option on.


NTL_GF2X_NOINLINE=off

# By default, the low-level GF2X multiplication routine in inlined.  This can
# potentially lead to some trouble on some platforms, and you can override the
# default by setting this flag.


NTL_GF2X_ALTCODE=off

# With this option, the default strategy for implmenting low-level GF2X
# multiplication is replaced with an alternative strategy.  This alternative
# strategy seems to work better on RISC machines with deep pipelines and high
# branch penalties (like a powerpc), but does no better (or even worse) on
# x86s.


NTL_GF2X_ALTCODE1=off

# Yet another alternative implementation for GF2X multiplication.


